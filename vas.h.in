#ifndef LIBVAS_VAS_H_
#define LIBVAS_VAS_H_

#include <stddef.h>

#define VAS_VERSION "${PROJECT_VERSION}"
#cmakedefine VAS_HAVE_PID_H  1
#cmakedefine VAS_USES_MEMCPY 1
#cmakedefine VAS_USES_WINAPI 2
#cmakedefine VAS_USES_MACH   4
#cmakedefine VAS_USES_PROCFS 8

#define VAS_IS_WIN32 (${WIN32}+0)
#define VAS_IS_POSIX (${UNIX}+0)
#define VAS_PTR_64BIT (${CMAKE_SIZEOF_VOID_P} == 8)
#define VAS_PTR_32BIT (${CMAKE_SIZEOF_VOID_P} == 4)


#if __STDC_VERSION__ >= 199901L /* C99 */

/**
 * Unsigned data type.
 * References a _data_ address in a virtual address space
 */

#include <stdint.h>
#ifdef UINTPTR_MAX
 typedef uintptr_t vas_addr_t;
#else
 typedef unsigned long long vas_addr_t;
#endif

#else

#if !VAS_IS_WIN32
typedef unsigned long vas_addr_t;

#else

#if VAS_PTR_64BIT
 typedef unsigned __int64 vas_addr_t;
#elif VAS_PTR_32BIT
 typedef unsigned long vas_addr_t;
#else
#error "CMake misconfiguration or very peculiar Windows detected"
#endif

#endif
#endif

#if VAS_HAVE_PID_H
#include <pid.h>
#elif VAS_IS_POSIX
#include <sys/types.h>
#elif VAS_IS_WIN32
typedef unsigned long pid_t;
#else
#error "pid_t undefined (Maybe install libpid?)"
#endif

/**
 * Get version from the library
 */
const char *vas_get_version(void);


/**
 * References a virtual address space
 */
typedef struct vas_t vas_t;

/**
 * Opens a handle to process id pid's address space
 */
vas_t *vas_open(pid_t, int flags);

/**
 * Closes a handle opened by vas_open and frees resources
 */
void vas_close(vas_t *);

/**
 * Reads size_t bytes from vas_t at vas_addr_t and
 * saves them to void*
 * The local and remote region may not overlap
 */
ssize_t vas_read(vas_t*, const vas_addr_t, void*, size_t);

/**
 * Write size_t to from vas_t at vas_addr_t from void*
 * The local and remote region may not overlap
 */
ssize_t vas_write(vas_t*, vas_addr_t, const void*, size_t);

/**
 * Effecient memory searching
 */
int vas_search(vas_t*, const vas_addr_t, const void*, size_t);

/**
 * atomically reading multiple values
 * Is this even viable?
 */
struct vas_addrvec {
    vas_addr_t remote;
    void *local;
    size_t size;
};

ssize_t vas_readv(vas_t*, const struct vas_addrvec[], int vec_len);

ssize_t vas_writev(vas_t*, const struct vas_addrvec[], int vec_len);

/**
 */
typedef struct vas_poll_t vas_poll_t;

vas_poll_t *vas_poll_new(vas_t*, vas_addr_t, size_t, int);
int vas_poll(vas_poll_t*, void*);
void vas_poll_del(vas_poll_t*);


void *vas_fmap(const char *);

/**
 * Duplicate
 */
vas_addr_t vas_dup(vas_t*, const vas_addr_t, size_t);

/**
 * Copy on write specified memory block(s)
 */
void *vas_cow(vas_t*, vas_addr_t, const vas_addr_t, size_t);


#endif
