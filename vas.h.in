#ifndef LIBVAS_VAS_H_
#define LIBVAS_VAS_H_

#define VAS_VERSION "${PROJECT_VERSION}"
#cmakedefine VAS_HAVE_LIBPID_H   1
#cmakedefine VAS_HAVE_MMAN_H     1
#cmakedefine VAS_USES_MEMCPY     1
#cmakedefine VAS_USES_WINAPI     2
#cmakedefine VAS_USES_MACH       4
#cmakedefine VAS_USES_PROCFS     8
#cmakedefine VAS_USES_PTRACE     32

#include "vas-types.h"




/**
 * @returns version string
 *
 * Get library version
 */
const char *vas_get_version(void);


/**
 * @returns pointer to static handle
 *          or NULL if operations on self aren't supported for the backend
 *
 * Retrieves the handle of the current VAS
 */
vas_t *vas_self(void);

/* TODO some vas_error() function */
enum {
    VAS_O_FORCE_SELF   = 1, /** Allow vas_open on own pid even if vas_self() == NULL **/
    VAS_O_REPORT_ERROR = 2, /** Report errors to stderr, except for malloc returning NULL
                                This is still work in progress. not all functions
                                report errors **/


    VAS_O_NOP          = 0
};


/**
 * @param pid   process id
 * @param flags has to be zero
 * @returns handle
 *
 * Opens a handle to a process' address space
 */
vas_t *vas_open(pid_t pid, int flags);

/**
 * @param vas handle
 *
 * Closes handle opened by vas_open and frees resources
 */
void vas_close(vas_t *vas);

/**
 * Reads size_t bytes from vas_t at vas_addr_t and
 * saves them to void*
 * The local and remote region may not overlap
 */
int vas_read(vas_t *vas, const vas_addr_t, void*, size_t);

/**
 * Write size_t to from vas_t at vas_addr_t from void*
 * The local and remote region may not overlap
 */
int vas_write(vas_t*, vas_addr_t, const void*, size_t);

/**
 * Effecient memory searching
 */
int vas_search(vas_t*, const vas_addr_t, const void*, size_t);

int vas_pagesize(void);

vas_ringbuf_t *vas_ringbuf_alloc(vas_t*, size_t pagecount, int flags);
void vas_ringbuf_free(vas_ringbuf_t *base);

/**
 * File mapping
 */
vas_addr_t vas_fmap(vas_t *vas, const char*, off_t, size_t, int flags);



/**
 * atomically reading multiple values
 * Is this even viable?
 */
struct vas_addrvec {
    vas_addr_t remote;
    void *local;
    size_t size;
};

int vas_readv(vas_t*, const struct vas_addrvec[], int vec_len);

int vas_writev(vas_t*, const struct vas_addrvec[], int vec_len);


/**
 * Poll a buffer for changes
 * On supporting platforms, this remaps the page, saving subsequent TLB flushes
 */
vas_poll_t *vas_poll_new(vas_t*, vas_addr_t, size_t, int);
int vas_poll(vas_poll_t*, void*);
void vas_poll_del(vas_poll_t*);


/**
 * Duplicate in malloc allocated space
 */
void *vas_dup(vas_t*, const vas_addr_t, size_t);

#ifdef VAS_USES_MACH
/**
 * Duplicate with CoW-Semantics if possible
 * CoW is possible if vas_dup_cow != vas_dup
 * \NOTE This will most likely involve a TLB flush on your system,
 *       So, it's not a silver bullet.
 */
void *vas_dup_cow(vas_t*, const vas_addr_t, size_t);
int vas_dup_cow_free(vas_t *vas, void* addr, size_t len);
#else
#include <stdlib.h>
#define vas_dup_cow vas_dup
#define vas_dup_cow_free(vas, addr, len) (free(addr), 0)
#endif


#endif
